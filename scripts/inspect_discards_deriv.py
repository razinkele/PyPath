"""Inspect deriv components for Discards at a given month to find drivers of biomass loss."""
import numpy as np
import pandas as pd
from pathlib import Path
from pypath.core.params import create_rpath_params
from pypath.core.ecopath import rpath
from pypath.core.ecosim import rsim_scenario, rsim_run
import importlib
import pypath.core.ecosim_deriv as ecosim_deriv
importlib.reload(ecosim_deriv)
deriv_vector = ecosim_deriv.deriv_vector
from pypath.core.ecosim import _build_link_matrix

REF = Path('tests/data/rpath_reference')
ECOPATH_DIR = REF / 'ecopath'
ECOSIM_DIR = REF / 'ecosim'
model_df = pd.read_csv(ECOPATH_DIR / 'model_params.csv')
diet_df = pd.read_csv(ECOPATH_DIR / 'diet_matrix.csv')

groups = model_df['Group'].tolist()
params = create_rpath_params(groups, [int(t) for t in model_df['Type'].tolist()])
params.model = model_df
params.diet = diet_df

model = rpath(params)
# Inspect initial DetFrac in RsimParams generated by rpath
initial_DetFrac = getattr(params, 'DetFrac', None)
print('Initial DetFrac shape (params):', getattr(initial_DetFrac, 'shape', type(initial_DetFrac)))
detfrom = getattr(params, 'DetFrom', None)
detto = getattr(params, 'DetTo', None)
print('Initial DetFrom:', detfrom[:20] if detfrom is not None else None)
print('Initial DetTo:', detto[:20] if detto is not None else None)
scenario = rsim_scenario(model, params, years=range(1, 101))
# DetFrac inside scenario.params (before running) may differ from params
pre_run_DetFrac = getattr(scenario.params, 'DetFrac', None)
print('Pre-run DetFrac shape (scenario.params):', getattr(pre_run_DetFrac, 'shape', type(pre_run_DetFrac)))
detfrom_pre = getattr(scenario.params, 'DetFrom', None)
detto_pre = getattr(scenario.params, 'DetTo', None)
print('Pre-run DetFrom sample:', detfrom_pre[:40] if detfrom_pre is not None else None)
print('Pre-run DetTo sample:', detto_pre[:40] if detto_pre is not None else None)
if detfrom_pre is not None and detto_pre is not None:
    print('Unique DetTo pre-run:', np.unique(detto_pre))
out = rsim_run(scenario, method='rk4', years=range(1, 101))
# DetFrac after run (scenario.params may have been mutated)
post_run_DetFrac = getattr(scenario.params, 'DetFrac', None)
print('Post-run DetFrac shape (scenario.params):', getattr(post_run_DetFrac, 'shape', type(post_run_DetFrac)))
py_biom = out.out_Biomass

month = 1199
state = py_biom[month].copy()

# Build params dict for deriv_vector
safe_params = {
    'NUM_GROUPS': scenario.params.NUM_GROUPS,
    'NUM_LIVING': scenario.params.NUM_LIVING,
    'NUM_DEAD': scenario.params.NUM_DEAD,
    'NUM_GEARS': scenario.params.NUM_GEARS,
    'PB': scenario.params.PBopt,
    'QB': scenario.params.FtimeQBOpt,
    'M0': scenario.params.MzeroMort,
    'Unassim': scenario.params.UnassimRespFrac,
    'ActiveLink': _build_link_matrix(scenario.params, scenario.params.QQ),
    'VV': _build_link_matrix(scenario.params, scenario.params.VV),
    'DD': _build_link_matrix(scenario.params, scenario.params.DD),
    'QQbase': _build_link_matrix(scenario.params, scenario.params.QQ),
    'Bbase': scenario.params.B_BaseRef,
    'PP_type': scenario.params.PP_type,
    'DetFrac': scenario.params.DetFrac,
}

forcing = {}
fishing = {'FishingMort': np.zeros(scenario.params.NUM_GROUPS + 1)}

d = deriv_vector(state.copy(), safe_params, forcing, fishing)
idx = scenario.params.spname.index('Discards')
print('Month', month, 'Discards idx', idx)
print('Discards biomass:', state[idx])
print('Derivative:', d[idx])

# Compute QQ as in deriv_vector / debug script
NUM_GROUPS = scenario.params.NUM_GROUPS
NUM_LIVING = scenario.params.NUM_LIVING
NUM_DEAD = scenario.params.NUM_DEAD
ActiveLink = _build_link_matrix(scenario.params, scenario.params.QQ) > 0
VV = _build_link_matrix(scenario.params, scenario.params.VV)
DD = _build_link_matrix(scenario.params, scenario.params.DD)
QQbase = _build_link_matrix(scenario.params, scenario.params.QQ)

BB = state.copy()
preyYY = np.zeros(NUM_GROUPS + 1)
for i in range(1, NUM_GROUPS + 1):
    if safe_params['Bbase'][i] > 0:
        preyYY[i] = BB[i] / safe_params['Bbase'][i]
predYY = np.zeros(NUM_GROUPS + 1)
for i in range(1, NUM_LIVING + 1):
    if safe_params['Bbase'][i] > 0:
        predYY[i] = 1.0 * BB[i] / safe_params['Bbase'][i]

QQ = np.zeros((NUM_GROUPS + 1, NUM_GROUPS + 1))
for pred in range(1, NUM_LIVING + 1):
    if BB[pred] <= 0:
        continue
    for prey in range(1, NUM_GROUPS + 1):
        if not ActiveLink[prey, pred]:
            continue
        if BB[prey] <= 0:
            continue
        vv = VV[prey, pred]
        dd = DD[prey, pred]
        qbase = QQbase[prey, pred]
        if qbase <= 0:
            continue
        PYY = preyYY[prey]
        PDY = predYY[pred]
        dd_term = dd / (dd - 1.0 + max(PYY, 1e-10)) if dd > 1.0 else 1.0
        vv_term = vv / (vv - 1.0 + max(PDY, 1e-10)) if vv > 1.0 else 1.0
        Q_calc = qbase * PDY * PYY * dd_term * vv_term
        QQ[prey, pred] = max(Q_calc, 0.0)

col = QQ[:, idx]
preds = list(enumerate(col))
preds_sorted = sorted(preds, key=lambda x: abs(x[1]), reverse=True)
print('\nTop predators consuming Discards (pred_idx, Q):')
for i, q in preds_sorted[:20]:
    name = scenario.params.spname[i]
    print(i, name, q)

# Print M0 losses and production/consumption approximations
M0 = safe_params['M0'][idx]
print('\nM0 (natural mortality) for Discards:', M0)
# Approximate consumption and production using QQ, VV
print('QQbase for Discards: (not available as a single attr; use QQbase matrix)')

# Inspect DetFrac entries mapping living groups -> this detritus index
NUM_LIVING = scenario.params.NUM_LIVING
det_idx = idx - NUM_LIVING
DetFrac = scenario.params.DetFrac
DF = np.asarray(DetFrac)
if DF.ndim == 0:
    DF = DF.reshape((1, 1))
elif DF.ndim == 1:
    DF = DF.reshape((DF.size, 1))
print('\nDetFrac original shape', getattr(DetFrac, 'shape', type(DetFrac)), 'normalized shape', DF.shape, 'det_idx', det_idx)
print('DetFrac column for Discards detritus index (non-zero entries):')
for grp in range(1, NUM_LIVING + 1):
    if DF.shape[1] > det_idx and DF[grp, det_idx] > 0:
        print(grp, scenario.params.spname[grp], 'DetFrac', DF[grp, det_idx])
# Use DF for further computations
DetFrac = DF

# Compute the same terms as in deriv: unas_input, mort_input, det_consumed, decay
unas_input = 0.0
for pred in range(1, NUM_LIVING + 1):
    total_consump = np.sum(QQ[1:, pred])
    unas_input += (total_consump * safe_params['Unassim'][pred] * DetFrac[pred, det_idx]) if DetFrac.shape[1] > det_idx else 0

mort_input = 0.0
for grp in range(1, NUM_LIVING + 1):
    mort_input += (safe_params['M0'][grp] * BB[grp] * DetFrac[grp, det_idx]) if DetFrac.shape[1] > det_idx else 0

det_consumed = np.sum(QQ[idx, 1 : NUM_LIVING + 1])
decay_rate = getattr(scenario.params, 'DetDecay', np.zeros(NUM_DEAD + 1))
decay = decay_rate[det_idx] * BB[idx] if len(decay_rate) > det_idx else 0

print('\nunas_input', unas_input, 'mort_input', mort_input, 'det_consumed', det_consumed, 'decay', decay)
print('\nDone')
